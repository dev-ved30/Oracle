

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>oracle.taxonomies &mdash; oracle 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=29a6c3e3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            oracle
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">oracle</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">oracle.taxonomies</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for oracle.taxonomies</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">networkx.drawing.nx_agraph</span><span class="w"> </span><span class="kn">import</span> <span class="n">graphviz_layout</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">oracle.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">BTS_to_Astrophysical_mappings</span>

<span class="c1"># NOTE: I am not super worried about the performance of this code since it will not be used to compute the losses while training the model. That code exists in loss.py and is optimized for speed.</span>

<span class="c1"># Name of the root node for the self</span>
<span class="n">root_label</span> <span class="o">=</span> <span class="s2">&quot;Alert&quot;</span>

<span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">set_default_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># Generic class to represent a taxonomy. Specific taxonomy classes inherit from this class and add their own nodes and edges.</span>
<div class="viewcode-block" id="Taxonomy">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Taxonomy</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to represent a taxonomy as a directed graph. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_label</span> <span class="o">=</span> <span class="n">root_label</span>

<div class="viewcode-block" id="Taxonomy.plot_taxonomy">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.plot_taxonomy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_taxonomy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the taxonomy using networkx and matplotlib.</span>

<span class="sd">        returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Plot the taxonomy.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">graphviz_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s1">&#39;dot&#39;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Taxonomy.plot_colored_taxonomy">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.plot_colored_taxonomy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_colored_taxonomy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the taxonomy, colored by values in </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_order_traversal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">()</span>

        <span class="n">color_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">label</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">level_order_traversal</span><span class="p">,</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">tolist</span><span class="p">())}</span>
        <span class="n">node_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">graphviz_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s1">&#39;dot&#39;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span> <span class="n">font_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Wistia&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Taxonomy.get_level_order_traversal">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_level_order_traversal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_level_order_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the level order traversal of the taxonomy.</span>

<span class="sd">        returns:</span>
<span class="sd">            level_order_nodes: list of nodes in the taxonomy ordered by level order traversal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Do a level order traversal of the tree to get an ordering of the nodes.</span>
        <span class="n">level_order_nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root_label</span><span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">level_order_nodes</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_parent_nodes">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_parent_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the parent nodes for each node in the taxonomy, ordered by level order traversal.</span>

<span class="sd">        returns:</span>
<span class="sd">            parents: list of parent nodes for each node in the taxonomy, ordered by level order traversal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the parent nodes for each node in the taxonomy, ordered by level order traversal.</span>
        <span class="n">level_order_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">()</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">level_order_nodes</span><span class="p">]</span>

        <span class="c1"># Make sure the root node has no parent</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)):</span>

            <span class="c1"># Make sure the graph is a tree.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Number of parents for each node should be 0 (for root) or 1.&#39;</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Make an exception for the root node since it should have no parent.</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">parents</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_sibling_masks">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_sibling_masks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sibling_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sibling masks for each node in the taxonomy, ordered by level order traversal.</span>

<span class="sd">        returns:</span>
<span class="sd">            masks: list of numpy arrays of sibling mask indices for the taxonomy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE: Sibling nodes are nodes that share the same parent node.</span>

        <span class="c1"># Get a list of all parents for all nodes in the taxonomy, ordered by level order traversal.</span>
        <span class="n">parent_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_nodes</span><span class="p">()</span>

        <span class="c1"># Get the unique parents, sorted alphabetically</span>
        <span class="n">unique_parent_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parent_nodes</span><span class="p">))</span>
        <span class="n">unique_parent_nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Create a mask for sibling nodes.</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">unique_parent_nodes</span><span class="p">:</span>
            <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parent_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="n">parent</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">masks</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_leaf_nodes">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_leaf_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the leaf nodes in the taxonomy.</span>

<span class="sd">        returns:</span>
<span class="sd">            leaf_nodes: list of leaf nodes in the taxonomy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the leaf nodes in the taxonomy</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">leaf_nodes</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_hierarchical_one_hot_encoding">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_hierarchical_one_hot_encoding">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_hierarchical_one_hot_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the hierarchical one-hot encoding for the labels.</span>
<span class="sd">        </span>
<span class="sd">        args:</span>
<span class="sd">            labels: list of labels to encode (n_samples). </span>

<span class="sd">        returns:</span>
<span class="sd">            all_encodings: 2D numpy array of hierarchical one-hot encodings (n_samples, n_nodes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">level_order_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">()</span>

        <span class="c1"># Assert that all labels are one of the nodes in the taxonomy.</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">level_order_nodes</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Label </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> is not a node in the taxonomy.&#39;</span>

        <span class="c1"># Array to store all the label encodings</span>
        <span class="n">all_encodings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">level_order_nodes</span><span class="p">)])</span>

        <span class="c1"># Loop through all the labels </span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            
            <span class="c1"># Get the path from the root to the label. Shortest path is guaranteed to be unique.</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">root_label</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

            <span class="c1"># Loop through all the nodes in the the path from the root to the leaf label.</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                
                <span class="c1"># Get the index of the node in the level order traversal.</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">level_order_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># Encoding of the labels where true nodes are 1 and everything else is 0. Ordered by level order traversal.</span>
                <span class="n">all_encodings</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">all_encodings</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_paths">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_paths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the paths from the root to the labels.</span>

<span class="sd">        args:</span>
<span class="sd">            labels: list of labels to compute paths for (n_samples). Each label should be a leaf node in the taxonomy.</span>

<span class="sd">        returns:</span>
<span class="sd">            paths: list of paths from the root to the labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">encodings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hierarchical_one_hot_encoding</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">level_order_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">())</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">encodings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">encodings</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">level_order_nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>  

        <span class="k">return</span> <span class="n">paths</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_depths">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_depths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_depths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the depths of the nodes in the taxonomy, ordered by level order traversal.</span>

<span class="sd">        returns:</span>
<span class="sd">            depths: list of depths of the nodes in the taxonomy, ordered by level order traversal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">level_order_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">()</span>

        <span class="c1"># Compute the shortest paths from the root node to each of the other nodes in the tree.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">level_order_nodes</span><span class="p">:</span>
            <span class="n">path_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_label</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_conditional_probabilities">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_conditional_probabilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_conditional_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the conditional probabilities from the logits, after applying the softmax function to sets of sibling nodes.</span>
<span class="sd">        </span>
<span class="sd">        args:</span>
<span class="sd">            logits: 2D torch tensor of logits (n_samples, n_nodes).</span>
<span class="sd">            epsilon: small value to avoid numerical problems with floating point numbers.</span>
<span class="sd">            </span>
<span class="sd">        returns:</span>
<span class="sd">            conditional_probabilities: 2D torch tensor of conditional probabilities (n_samples, n_nodes).&quot;&quot;&quot;</span>

        <span class="n">masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sibling_masks</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
            
            <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

            <span class="c1"># Get the e^logits</span>
            <span class="n">exps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>

            <span class="c1"># Multiply (dot product) the e^logits with the mask to maintain just the e^logits values that belong to this mask. All other values will be zeros.</span>
            <span class="n">masked_exps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">exps</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

            <span class="c1"># Find the sum of the e^logits values that belong to the mask. Do this for each element in the batch separately. Add a small value to avoid numerical problems with floating point numbers.</span>
            <span class="n">masked_sums</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masked_exps</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span>

            <span class="c1"># Compute the softmax by dividing the e^logits with the sum (e^logits)</span>
            <span class="n">softmax</span> <span class="o">=</span> <span class="n">masked_exps</span><span class="o">/</span><span class="n">masked_sums</span>

            <span class="c1"># (1 - mask) * y_pred gets the logits for all the values not in this mask and zeros out the values in the mask. Add those back so that we can repeat the process for other masks.</span>
            <span class="n">logits</span> <span class="o">=</span> <span class="n">softmax</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">logits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">logits</span></div>

    
<div class="viewcode-block" id="Taxonomy.get_nodes_by_depth">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_nodes_by_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_nodes_by_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nodes in the taxonomy grouped by their depth.</span>

<span class="sd">        returns:</span>
<span class="sd">            nodes_by_depth: dictionary where keys are depths and values are lists of nodes at that depth.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">depths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_depths</span><span class="p">()</span>
        <span class="n">level_order_traversal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">())</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaf_nodes</span><span class="p">()</span>

        <span class="n">nodes_by_depth</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Loop through all depths</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">depths</span><span class="p">):</span>
            
            <span class="c1"># Get the indices of the nodes at this depth in the level order traversal.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">depths</span><span class="o">==</span><span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nodes_by_depth</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span> <span class="o">=</span> <span class="n">level_order_traversal</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Add the leaf nodes to the nodes_by_depth dictionary.</span>
        <span class="n">nodes_by_depth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nodes_by_depth</span></div>

            
<div class="viewcode-block" id="Taxonomy.get_class_probabilities">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.Taxonomy.get_class_probabilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_class_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditional_probabilities</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the class probabilities from the conditional probabilities.</span>

<span class="sd">        args:</span>
<span class="sd">            conditional_probabilities: 2D numpy array of conditional probabilities (n_samples, n_nodes).</span>

<span class="sd">        returns:</span>
<span class="sd">            class_probabilities: 2D numpy array of class probabilities (n_samples, n_nodes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">conditional_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span> <span class="s1">&#39;Number of nodes in the taxonomy should match the number of columns in the conditional probabilities.&#39;</span>

        <span class="c1"># TODO: This could probably be sped up. I am implementing the dumb version for now but we might want to optimize this, especially if we want to deploy since this will be used during inference.</span>

        <span class="c1"># Conditional probabilities are the output of the model. We use those to compute the class probabilities.</span>
        <span class="n">class_probabilities</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">conditional_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Get the leaf nodes for the taxonomy.</span>
        <span class="n">level_order_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">level_order_nodes</span><span class="p">):</span>
            
            <span class="c1"># Skip the root node since its class probability should be equal to its conditional probability and both should be 1.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
            
                <span class="c1"># Get the path from the root to the another node in the taxonomy.</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">root_label</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># Get the indices of the nodes in the path.</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>

                <span class="c1"># Multiply the conditional probabilities of the nodes in the path to get the class probability.</span>
                <span class="n">class_probabilities</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">conditional_probabilities</span><span class="p">[:,</span><span class="n">indices</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">class_probabilities</span></div>
</div>


<div class="viewcode-block" id="BTS_Taxonomy">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.BTS_Taxonomy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BTS_Taxonomy</span><span class="p">(</span><span class="n">Taxonomy</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">root_label</span><span class="p">)</span>

        <span class="n">level_1_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Persistent&#39;</span><span class="p">,</span><span class="s1">&#39;Transient&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_1_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">root_label</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">level_1_nodes</span><span class="p">])</span>

        <span class="n">level_2a_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AGN&#39;</span><span class="p">,</span><span class="s1">&#39;CV&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_2a_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Persistent&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">level_2a_nodes</span><span class="p">])</span>

        <span class="c1"># Level 2b nodes for SN-like events</span>
        <span class="n">level_2b_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SN-Ia&#39;</span><span class="p">,</span><span class="s1">&#39;SN-II&#39;</span><span class="p">,</span><span class="s1">&#39;SN-Ib/c&#39;</span><span class="p">,</span><span class="s1">&#39;SLSN&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_2b_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Transient&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">level_2b_nodes</span><span class="p">])</span></div>



<div class="viewcode-block" id="ORACLE_Taxonomy">
<a class="viewcode-back" href="../../oracle.html#oracle.taxonomies.ORACLE_Taxonomy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ORACLE_Taxonomy</span><span class="p">(</span><span class="n">Taxonomy</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">root_label</span><span class="p">)</span>

        <span class="c1"># Level 1</span>
        <span class="n">level_1_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Transient&#39;</span><span class="p">,</span> <span class="s1">&#39;Variable&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_1_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">root_label</span><span class="p">,</span> <span class="n">level_1_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_1_node</span> <span class="ow">in</span> <span class="n">level_1_nodes</span><span class="p">])</span>

        <span class="c1"># Level 2a nodes for Transients</span>
        <span class="n">level_2a_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SN&#39;</span><span class="p">,</span> <span class="s1">&#39;Fast&#39;</span><span class="p">,</span> <span class="s1">&#39;Long&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_2a_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Transient&#39;</span><span class="p">,</span> <span class="n">level_2a_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_2a_node</span> <span class="ow">in</span> <span class="n">level_2a_nodes</span><span class="p">])</span>

        <span class="c1"># Level 2b nodes for Transients</span>
        <span class="n">level_2b_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Periodic&#39;</span><span class="p">,</span> <span class="s1">&#39;AGN&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_2b_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Variable&#39;</span><span class="p">,</span> <span class="n">level_2b_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_2b_node</span> <span class="ow">in</span> <span class="n">level_2b_nodes</span><span class="p">])</span>

        <span class="c1"># Level 3a nodes for SN Transients</span>
        <span class="n">level_3a_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SNIa&#39;</span><span class="p">,</span> <span class="s1">&#39;SNIb/c&#39;</span><span class="p">,</span> <span class="s1">&#39;SNIax&#39;</span><span class="p">,</span> <span class="s1">&#39;SNI91bg&#39;</span><span class="p">,</span> <span class="s1">&#39;SNII&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_3a_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;SN&#39;</span><span class="p">,</span> <span class="n">level_3a_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_3a_node</span> <span class="ow">in</span> <span class="n">level_3a_nodes</span><span class="p">])</span>

        <span class="c1"># Level 3b nodes for Fast events Transients</span>
        <span class="n">level_3b_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;KN&#39;</span><span class="p">,</span> <span class="s1">&#39;Dwarf Novae&#39;</span><span class="p">,</span> <span class="s1">&#39;uLens&#39;</span><span class="p">,</span> <span class="s1">&#39;M-dwarf Flare&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_3b_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Fast&#39;</span><span class="p">,</span> <span class="n">level_3b_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_3b_node</span> <span class="ow">in</span> <span class="n">level_3b_nodes</span><span class="p">])</span>

        <span class="c1"># Level 3c nodes for Long events Transients</span>
        <span class="n">level_3c_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SLSN&#39;</span><span class="p">,</span> <span class="s1">&#39;TDE&#39;</span><span class="p">,</span> <span class="s1">&#39;ILOT&#39;</span><span class="p">,</span> <span class="s1">&#39;CART&#39;</span><span class="p">,</span> <span class="s1">&#39;PISN&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_3c_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Long&#39;</span><span class="p">,</span> <span class="n">level_3c_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_3c_node</span> <span class="ow">in</span> <span class="n">level_3c_nodes</span><span class="p">])</span>

        <span class="c1"># Level 3d nodes for periodic stellar events</span>
        <span class="n">level_3d_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cepheid&#39;</span><span class="p">,</span> <span class="s1">&#39;RR Lyrae&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta Scuti&#39;</span><span class="p">,</span> <span class="s1">&#39;EB&#39;</span><span class="p">]</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">level_3d_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Periodic&#39;</span><span class="p">,</span> <span class="n">level_3d_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">level_3d_node</span> <span class="ow">in</span> <span class="n">level_3d_nodes</span><span class="p">])</span></div>


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1">#&lt;-- Example usage of the taxonomy class --&gt;</span>

    <span class="n">taxonomy</span> <span class="o">=</span> <span class="n">BTS_Taxonomy</span><span class="p">()</span>
    <span class="n">taxonomy</span><span class="o">.</span><span class="n">plot_taxonomy</span><span class="p">()</span>

    <span class="n">all_classes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">BTS_to_Astrophysical_mappings</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="c1">#taxonomy.get_hierarchical_one_hot_encoding(all_classes)</span>
    <span class="n">taxonomy</span><span class="o">.</span><span class="n">plot_colored_taxonomy</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_hierarchical_one_hot_encoding</span><span class="p">([</span><span class="s1">&#39;SN-II&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_nodes_by_depth</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_leaf_nodes</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">())</span>


    <span class="c1"># Create a taxonomy object</span>
    <span class="n">taxonomy</span> <span class="o">=</span> <span class="n">ORACLE_Taxonomy</span><span class="p">()</span>

    <span class="c1"># Print the nodes after doing a level order traversal</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_level_order_traversal</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_parent_nodes</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_sibling_masks</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_leaf_nodes</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_hierarchical_one_hot_encoding</span><span class="p">([</span><span class="s1">&#39;SNIa&#39;</span><span class="p">,</span> <span class="s1">&#39;SNIb/c&#39;</span><span class="p">,</span> <span class="s1">&#39;SNIax&#39;</span><span class="p">,</span> <span class="s1">&#39;SNI91bg&#39;</span><span class="p">,</span> <span class="s1">&#39;SNII&#39;</span><span class="p">,</span> <span class="s1">&#39;SN&#39;</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_paths</span><span class="p">([</span><span class="s1">&#39;SNIa&#39;</span><span class="p">,</span> <span class="s1">&#39;SNIb/c&#39;</span><span class="p">,</span> <span class="s1">&#39;SNIax&#39;</span><span class="p">,</span> <span class="s1">&#39;SNI91bg&#39;</span><span class="p">,</span> <span class="s1">&#39;SNII&#39;</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_class_probabilities</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">get_conditional_probabilities</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxonomy</span><span class="o">.</span><span class="n">nodes</span><span class="p">())))))</span>

    <span class="n">taxonomy</span><span class="o">.</span><span class="n">plot_taxonomy</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Ved Shah.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>